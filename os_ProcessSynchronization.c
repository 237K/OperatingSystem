///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	[Operating System]
//
//	OS Linux
//	2019. 04. 25
//
//	<Process Synchronization>
//		공유데이터에 대한 동시 접근은 데이터의 일관성을 해칠 수 있음
//		논리 주소 공간을 공유하는 협력적 프로세스들에게 규칙을 제공하여 데이터 일관성을 유지할 수 있도록 해야 함
//	
//		* 경쟁 상황 : 여러 개의 프로세스가 동일한 자료에 접근하여 조작하고 그 실행 결과가 접근이 발생한 순서에 의존하는 상황
//		1. 임계구역 문제 (The Critical-Section Problem)
//			* 임계구역 (critical section) : 다른 프로세스와 공유하는 변수를 변경하거나 테이블을 갱신하거나 파일을 쓰는 등의 작업을 수행
//			* 진입구역 (entry section)
//			* 퇴출구역 (exit section)
//			* 나머지구역 (remainder section)
//			임계구역 문제를 해결하기 위해선 반드시 다음의 세 가지 조건을 충족해야 함
//			1) Mutual exclusion : 한 프로세스가 자신의 임계구역에서 실행되면 다른 프로세스들은 그들 자신의 임계구역에서 실행될 수 없음
//			2) Progress : 자기 임계구역에서 실행되는 프로세스가 없고 그들 자신의 임계구역으로 진입하려는 프로세스들이 있다면,
//						  나머지 구역에서 실행 중이지 않은 프로세스들만 누가 그 임계구역으로 진입할 지 결정하는데 참여할 수 있음
//						  * 이 선택은 무한히 연기될 수 없음
//			3) Bounded waiting : 프로세스가 자신의 임계구역에 진입하려는 요청을 한 후부터 그 요청이 허용될 때 까지
//								 다른 프로세스들이 그들 자신의 임계구역에 진입하도록 허용되는 횟수에 한계가 있어야 함
//
//		2. Peterson's Solution
//		3. Synchronization Hardware
//			1) test_and_set()
//			2) compare_and_swap()
//		4. Mutex Locks
//			1) acquire() / release()
//			2) 프로세스가 임계구역에 있는 동안 임계구역에 들어가기 원하는 다른 프로세스들은 acquire() 함수를 호출하는 반복문을 실행
//			   -> spinlock : CPU사이클을 낭비하긴 하지만 context switch는 하지 않아도 된다는 것이 장점
//		5. Semaphores
//			1) 이진 세마포
//			2) 카운팅 세마포
//				a) 각 자원을 사용하려는 프로세스는 세마포에 wait()연산 수행. 세마포 값--
//				b) 프로세스가 자원을 방출할 때 signal()연산 수행. 세마포 값++
//				c) 세마포 값이 0이되면 모든 자원이 사용 중임. 이후 자원을 사용하려는 프로세스는 세마포 값이 0보다 커질 때까지 봉쇄
//			3) busy waiting을 극복하기 위해
//				a) 프로세스가 wait()연산을 실행하고 세마포 값이 양수가 아니면 프로세스는 대기
//				b) spinlock을 실행하지 않고 자신을 봉쇄시킴. 봉쇄연산은 프로세스를 대기 큐에 넣음
//				c) 이후 제어가 스케줄러로 넘어가고 스케줄러는 다른 프로세스를 실행하기 위해 큐에서 선택함
//				d) 프로세스는 wakeup()연산에 의해 재시작
//
//		6. Deadlock and Starvation
//			1) 한 집합 내의 모든 프로세스들이 그 집합 내의 다른 프로세스만이 유발할 수 있는 사건을 기다릴 때
//		7. Priority Inversion
//			1) 높은 우선순위 프로세스가 낮은 우선순위 프로세스에 의해 접근되는 커널 데이터를 읽거나 변경할 필요가 있을 때
//			  높은 우선순위 프로세스가 낮은 우선순위 프로세스가 끝나길 기다려야 하므로 문제가 생김
//			2) 우선순위 상속 프로토콜(priority-inheritance protocol)을 구현함으로써 해결할 수 있음
//		8. 고전적인 동기화 문제들
//			1) 유한 버퍼 문제
//			2) Readers-Writers 문제
//			3) 식사하는 철학자들 문제
//
//		9. 모니터
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	Process Synchronization
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//	Peterson's Solution	///////////////////////////////////////////////////////////////////////////////////////////////////////////
do
{
	flag[i] = TRUE;					//	flag[i]가 TRUE이면
	turn = j;						//	반드시 turn은 j여야 함

	//	j프로세스 실행
	while (flag[j] && turn == j);	//	flag[j]가 TRUE이고 j turn일 동안

	critical_section;				//	임계구역 실행

	flag[i] = FALSE;

	remainder_section;

} while (TRUE);
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//	Mutex Locks	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool available;
do
{
	//	락 획득
	acquire()
	{
		while (!available);
		available = false;
	}

	critical_section;

	//	락 반환
	release()
	{
		available = true;
	}

	remainder_section;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//	Semaphore	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
typedef struct
{
	int value;
	struct process *list;	//spinlock을 실행하지 않고, 기다려야 하는 세마포를 list에 넣음
} semaphore;

void wait(semaphore *S)
{
	//	wait를 실행하면 value-- 하고
	S->value--;

	//	value가 양수가 아니면
	if (S->value < 0)
	{
		//	list에 넣고 블락(이제 임계영역이 가용할 때 까지 wait를 호출하지 않음)
		S->list.push(S);
		block();
	}
}

void signal(semaphore *S)
{
	S->value++;
	if (S->value <= 0)
	{
		process P;
		P = S->list.pop();
		wakeup(P);
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//	Monitor	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct monitor {};
monitor DiningPhilosophers
{
	enum{THINKING, HUNGRY, EATING} state[5];
	condition self[5];

	void pickup(int i)
	{
		state[i] = HUNGRY;
		test(i);
		if (state[i] != EATING) self[i].wait();
	}

	void putdown(int i)
	{
		state[i] = THINKING;
		test((i + 4) % 5);
		test((i + 1) % 5);
	}

	void test(int i)
	{
		if (state[(i + 4) % 5] != EATING) && (state[i] == HUNGRY) && (state[(i + 1) % 5] != EATING)
		{
			state[i] = EATING;
			self[i].signal();
		}
	}

	initialization code()
	{
		for (int i = 0; i < 5; ++i)
			state[i] = THINKING;
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////